"""PowerShell wrapper generator for argparse-based Python scripts.

This module provides functionality to generate PowerShell wrapper scripts that provide
a native PowerShell interface to Python scripts using argparse.
"""

from __future__ import annotations

import argparse
import re
from pathlib import Path


def generate_ps1_wrapper(
    parser: argparse.ArgumentParser,
    script_path: Path,
    output_dir: Path,
    *,
    skip_dests: set[str] | None = None,
) -> Path:
    """Generate a PowerShell wrapper script for an argparse-based Python script.

    Args:
        parser: The ArgumentParser object from the Python script
        script_path: Path to the Python script to wrap
        output_dir: Directory where the .ps1 file will be created
        skip_dests: Set of argument destinations to skip in the wrapper

    Returns:
        Path to the generated .ps1 file

    Raises:
        ValueError: If output_dir doesn't exist or isn't a directory

    Example:
        >>> import argparse
        >>> from pathlib import Path
        >>> parser = argparse.ArgumentParser(description="My script")
        >>> parser.add_argument("input", type=Path, help="Input file")
        >>> parser.add_argument("-v", "--verbose", action="store_true")
        >>> script_path = Path(__file__).resolve()
        >>> output = generate_ps1_wrapper(parser, script_path, Path("."))
        >>> print(f"Generated: {output}")
    """
    if skip_dests is None:
        skip_dests = set()

    if not output_dir.exists():
        raise ValueError(f"Output directory does not exist: {output_dir}")
    if not output_dir.is_dir():
        raise ValueError(f"Output path is not a directory: {output_dir}")

    script_name = script_path.stem
    ps1_path = output_dir / f"{script_name}.ps1"

    # Generate PowerShell script content
    ps1_content = _generate_ps1_content(parser, script_path, skip_dests)

    # Write to file
    ps1_path.write_text(ps1_content, encoding="utf-8")

    return ps1_path


def _generate_ps1_content(
    parser: argparse.ArgumentParser,
    script_path: Path,
    skip_dests: set[str],
) -> str:
    """Generate the content of the PowerShell wrapper script.

    Args:
        parser: The ArgumentParser object
        script_path: Path to the Python script
        skip_dests: Set of argument destinations to skip

    Returns:
        String containing the complete PowerShell script
    """
    param_defs: list[str] = []
    arg_mappings: list[str] = []

    # Process each action from the parser
    for action in parser._actions:
        # Skip help action
        if action.dest == "help":
            continue

        dest = action.dest
        if dest in skip_dests:
            continue

        # Get the first option string (prefer long form)
        option_strings = action.option_strings
        if not option_strings:
            # Positional argument
            param_name = _to_pascal_case(dest)
            param_def = _generate_positional_param(action, param_name)
            param_defs.append(param_def)
            arg_mappings.append(
                f'    if ($PSBoundParameters.ContainsKey("{param_name}")) {{\n        $pythonArgs += ${{param_name}}\n    }}'
            )
        else:
            # Optional argument
            param_name = _to_pascal_case(dest)
            option_string = _get_preferred_option_string(list(option_strings))
            param_def = _generate_optional_param(action, param_name)
            param_defs.append(param_def)

            # Check if it's a boolean flag by action name
            action_type = type(action).__name__
            if (
                action_type in ("_StoreTrueAction", "_StoreFalseAction")
                or action.type is None
                and action.nargs == 0
            ):
                # Boolean flag
                arg_mappings.append(
                    f'    if (${param_name}) {{\n        $pythonArgs += "{option_string}"\n    }}'
                )
            elif action.type is not None:
                # Value argument
                arg_mappings.append(
                    f'    if ($PSBoundParameters.ContainsKey("{param_name}")) {{\n        $pythonArgs += "{option_string}", ${{param_name}}\n    }}'
                )
            else:
                # Default case
                arg_mappings.append(
                    f'    if ($PSBoundParameters.ContainsKey("{param_name}")) {{\n        $pythonArgs += "{option_string}", ${{param_name}}\n    }}'
                )

    # Build the complete script
    params_block = ",\n".join(param_defs)
    args_block = "\n".join(arg_mappings)

    description = parser.description or "Generated PowerShell wrapper"
    script_path_str = str(script_path).replace("\\", "\\\\")

    ps1_script = f"""<#
.SYNOPSIS
{description}

.DESCRIPTION
This PowerShell script is a wrapper for the Python script: {script_path.name}
It provides a native PowerShell interface to the Python script.

Auto-generated by ps1-wrapper
#>

[CmdletBinding()]
param(
{params_block}
)

$ErrorActionPreference = "Stop"

# Find Python executable
$pythonCmd = Get-Command python -ErrorAction SilentlyContinue
if (-not $pythonCmd) {{
    Write-Error "Python is not found in PATH"
    exit 1
}}

# Build arguments array
$pythonArgs = @("{script_path_str}")
{args_block}

# Execute Python script
& $pythonCmd.Source @pythonArgs
exit $LASTEXITCODE
"""

    return ps1_script


def _to_pascal_case(name: str) -> str:
    """Convert snake_case or kebab-case to PascalCase.

    Args:
        name: String in snake_case or kebab-case

    Returns:
        String in PascalCase

    Examples:
        >>> _to_pascal_case("input_file")
        'InputFile'
        >>> _to_pascal_case("dry-run")
        'DryRun'
    """
    # Replace underscores and hyphens with spaces, then title case
    words = re.sub(r"[_-]", " ", name).split()
    return "".join(word.capitalize() for word in words)


def _get_preferred_option_string(option_strings: list[str]) -> str:
    """Get the preferred option string (prefer long form over short).

    Args:
        option_strings: List of option strings like ['-v', '--verbose']

    Returns:
        Preferred option string (long form if available)
    """
    long_options = [opt for opt in option_strings if opt.startswith("--")]
    return long_options[0] if long_options else option_strings[0]


def _generate_positional_param(action: argparse.Action, param_name: str) -> str:
    """Generate PowerShell parameter definition for a positional argument.

    Args:
        action: The argparse Action object
        param_name: PowerShell parameter name (PascalCase)

    Returns:
        PowerShell parameter definition string
    """
    param_type = _get_ps1_type(action)

    # Handle required vs optional
    if action.required:
        param_attrs = "[Parameter(Mandatory=$true, Position=0)]"
    else:
        param_attrs = "[Parameter(Position=0)]"

    return f"    {param_attrs}\n    [{param_type}]${param_name}"


def _generate_optional_param(action: argparse.Action, param_name: str) -> str:
    """Generate PowerShell parameter definition for an optional argument.

    Args:
        action: The argparse Action object
        param_name: PowerShell parameter name (PascalCase)

    Returns:
        PowerShell parameter definition string
    """
    param_type = _get_ps1_type(action)

    return f"    [{param_type}]${param_name}"


def _get_ps1_type(action: argparse.Action) -> str:
    """Determine the PowerShell parameter type from argparse action.

    Args:
        action: The argparse Action object

    Returns:
        PowerShell type string
    """
    # Check if it's a boolean flag by action type name
    action_type = type(action).__name__
    if action_type in ("_StoreTrueAction", "_StoreFalseAction"):
        return "switch"

    if action.type is None:
        return "string"

    # Check for common types
    type_name = getattr(action.type, "__name__", str(action.type))

    type_mapping = {
        "int": "int",
        "float": "double",
        "Path": "string",
        "bool": "switch",
    }

    return type_mapping.get(type_name, "string")
